package io.crnk.gen.java;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import io.crnk.core.queryspec.PathSpec;
import io.crnk.core.queryspec.typed.PrimitivePath;
import io.crnk.core.queryspec.typed.ResourcePathBase;
import io.crnk.core.resource.annotations.JsonApiRelation;
import io.crnk.core.resource.annotations.JsonApiResource;

import javax.annotation.Generated;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeMirror;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.io.Writer;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class CrnkProcessor extends AbstractProcessor {

    private static final String TYPE_SUFFIX = "Type";

    @Override
    public void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
    }

    @Override
    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnv) {
        Messager messager = processingEnv.getMessager();

        Set<? extends Element> resourceElements = roundEnv.getElementsAnnotatedWith(JsonApiResource.class);

        Set<String> resourceNames = new HashSet<>();
        for (Element element : resourceElements) {
            TypeElement typeElement = (TypeElement) element;
            resourceNames.add(typeElement.getQualifiedName().toString());
        }

        for (Element element : resourceElements) {

            if (element.getKind() != ElementKind.CLASS) {
                messager.printMessage(Diagnostic.Kind.ERROR, "Can be applied to class.");
                return true;
            }

            TypeElement typeElement = (TypeElement) element;

            AnnotationSpec annotationSpec = AnnotationSpec.builder(Generated.class).addMember("value", "\"Generated by Crnk annotation processor\"").build();

            TypeSpec.Builder typeBuilder = TypeSpec.classBuilder(getSimpleName(element))
                    .addModifiers(Modifier.PUBLIC)
                    .addAnnotation(annotationSpec)
                    .superclass(ResourcePathBase.class);

            addConstants(typeElement, typeBuilder);
            addConstructors(typeElement, typeBuilder);
            addFields(typeElement, typeBuilder);

            writeType(element, typeBuilder);
        }
        return true;
    }

    private void addConstants(TypeElement typeElement, TypeSpec.Builder typeBuilder) {
        TypeName typeName = ClassName.bestGuess(getSimpleName(typeElement));
        String name = firstToLower(typeElement.getSimpleName().toString());

        FieldSpec.Builder fieldBuilder = FieldSpec.builder(typeName, name, Modifier.STATIC, Modifier.PUBLIC);
        fieldBuilder.initializer("new " + typeName.toString() + "()");
        typeBuilder.addField(fieldBuilder.build());
    }

    private String firstToLower(String value) {
        return Character.toLowerCase(value.charAt(0)) + value.substring(1);
    }


    private void addConstructors(TypeElement typeElement, TypeSpec.Builder typeBuilder) {
        MethodSpec.Builder defaultConstructor = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC)
                .addStatement(String.format("super(PathSpec.empty())"));
        typeBuilder.addMethod(defaultConstructor.build());

        MethodSpec.Builder pathConstructor = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC)
                .addParameter(PathSpec.class, "pathSpec")
                .addStatement(String.format("super(pathSpec)"));
        typeBuilder.addMethod(pathConstructor.build());
    }

    private String getSimpleName(Element element) {
        return getGeneratedTypeName(element.getSimpleName().toString());
    }

    private String getPackageName(Element element) {
        return processingEnv.getElementUtils().getPackageOf(element).getQualifiedName().toString();
    }

    private void writeType(Element element, TypeSpec.Builder typeBuilder) {
        try {
            String packageName = getPackageName(element);
            JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(getPackageName(element) + "." + getSimpleName(element), element);

            try (Writer writer = sourceFile.openWriter()) {
                JavaFile.builder(packageName, typeBuilder.build())
                        .indent(" ")
                        .build()
                        .writeTo(writer);
            }

        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
    }

    private void addFields(TypeElement typeElement, TypeSpec.Builder typeBuilder) {
        List<? extends Element> elements = typeElement.getEnclosedElements();

        Set<String> relationships = new HashSet<>();
        for (Element member : elements) {
            String memberName = getMemberName(member);
            if (memberName != null && member.getAnnotation(JsonApiRelation.class) != null) {
                relationships.add(memberName);
            }
        }

        for (Element member : elements) {
            String memberName = getMemberName(member);
            if (memberName != null && member.getKind() == ElementKind.METHOD) {
                TypeMirror memberType = member.asType();

                boolean isRelationship = relationships.contains(memberName);

                TypeName pathImpl = TypeName.get(PrimitivePath.class);
                if (isRelationship) {
                    pathImpl = getRelationshipType(memberType);
                }

                MethodSpec.Builder main = MethodSpec.methodBuilder(memberName)
                        .addModifiers(Modifier.PUBLIC)
                        .addStatement(String.format("return new %s(append(\"%s\"))", pathImpl.toString(), memberName))
                        .returns(pathImpl);

                typeBuilder.addMethod(main.build());
            }
        }

    }

    private TypeName getRelationshipType(TypeMirror memberType) {
        String memberTypeStr = memberType.toString();
        int sep = memberTypeStr.indexOf("<");
        if (sep != -1) {
            memberTypeStr = memberTypeStr.substring(sep + 1, memberTypeStr.lastIndexOf(">"));
        }
        if (memberTypeStr.startsWith("()")) {
            memberTypeStr = memberTypeStr.substring(2);
        }
        memberTypeStr = getGeneratedTypeName(memberTypeStr);
        return ClassName.bestGuess(memberTypeStr);
    }

    private String getGeneratedTypeName(String name) {
        if (name.endsWith("Entity")) {
            name = name.substring(0, name.length() - 6);
        }
        if (name.endsWith("Resource")) {
            name = name.substring(0, name.length() - 8);
        }
        return name + TYPE_SUFFIX;
    }

    private String getMemberName(Element member) {
        String memberName = member.getSimpleName().toString();
        if (member.getKind() == ElementKind.METHOD) {
            boolean isGetter = memberName.startsWith("get");
            boolean isBoolean = memberName.startsWith("is");
            if (isGetter || isBoolean) {
                String fieldName = memberName.substring(isGetter ? 3 : 2);
                return firstToLower(fieldName);
            }
            return null;
        } else if (member.getKind() == ElementKind.FIELD) {
            return memberName;
        }
        return null;
    }

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        Set<String> set = new HashSet<>();
        set.add(JsonApiResource.class.getName());
        return set;
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.RELEASE_8;
    }
}